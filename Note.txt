So far we have learned how to work with RabbitMQ and Spring Boot and send messages via RabbitTemplate.
Now we want to implement a better mechanism for sending and receiving messages, namely using JSON as the message format.
This is called implementing a JSON Message Converter, which eliminates the need to manually convert messages.
We send a message (DummyMessage) from the Producer.
This message is stored in JSON format (without manually converting it).
In the Consumer, the message is received and processed without any problems.
Here we have manually converted the message to JSON! But we want this to be done automatically.
(String jsonMessage = objectMapper.writeValueAsString(myMessage);)
ğŸ”¹ How do we solve this problem?
Using Jackson2JsonMessageConverter, which automatically converts our messages between JSON and Java Object.

Prefetch Count allows you to control how many messages are sent to a consumer at a time.
Suppose you set the prefetch count to 250. Now, when a consumer connects to RabbitMQ and requests messages to process, 250 messages are sent to the consumer at a time.
If the number of messages is large and the consumer processing is slow, some consumers may become idle because they have no messages to process, even if other consumers are processing.
For example, if you have 500 messages in the queue, and you have 2 consumers each receiving 250 messages, but the consumers are processing very slowly (say 20 seconds per message), the other consumers may not receive any messages and become idle.
Scenario 1:
When we set the prefetch value to 250, all 500 messages are sent to two consumers. But since consumers are slow, all messages are sent to consumers 1 and 2 and consumer 3 does not receive any messages.
Scenario 2:
Now that we have changed the prefetch count to 1, consumers receive messages one by one. Therefore, more consumers are active simultaneously and all messages are distributed equally among consumers.
In case of slow processing, a low prefetch count (e.g. 1) can be useful so that messages are sent one by one and all consumers are active.
For faster processing, we can choose a higher prefetch count (e.g. 250) so that messages are sent to consumers quickly.

Default prefetch value:
In Spring, the default value for prefetch is 250. This means that each consumer can hold up to 250 unacknowledged messages in memory. This value is not set by default in the application.yaml configuration.

Effect of setting the prefetch value:
If we change the prefetch value to 1, this means that each consumer can only hold one unacknowledged message in memory.
In this case, when the producer sends 500 messages to the queue and then stops, these messages are distributed evenly among all consumers and each consumer receives the messages one by one.

Why is prefetch important?:
If the processing time in consumers is long, a low prefetch value (such as 1) helps to distribute the messages evenly among all consumers and no consumer is left without work. Whereas if the prefetch value is high (e.g. 250), some consumers may be busy processing messages while others remain idle.

ğŸ”¹ When a single consumer listens to a single queue, the processing order is absolutely guaranteed.
âœ… Messages are processed in the same order they arrived at the queue.
For example:
ğŸ“© Messages: A â†’ B â†’ C â†’ D â†’ E
ğŸ”„ Processing order: A â†’ B â†’ C â†’ D â†’ E (exactly the same order)

If we have multiple consumers
ğŸ”¹ When multiple consumers are on the same queue, the processing order is no longer guaranteed!
ğŸ”¹ RabbitMQ divides messages between consumers based on the prefetch value.
âœ… Example: Let's say we have 10 messages and 2 consumers, each with prefetch = 50.
âœ… Messages are divided like this:
Messages 1, 3, 5, 7, 9 â†’ to the first consumer
Messages 2, 4, 6, 8, 10 â†’ to the second consumer
ğŸ’¡ But if one of the consumers is slower, its messages are processed later.
For example:
Consumer 1: Processes each message for 1 second.
Consumer 2: Processes each message for 3 seconds.
âŒ Result: The processing order is messed up!
ğŸ“© Received messages: 1, 2, 3, 5, 4, 6, 7, 8, 9, 10
ğŸš¨ Problem: Message 5 was processed before message 4! So the order is not respected.

Why is the order of message processing important?
ğŸ”¹ Suppose we have an Invoice system and three types of messages are sent to a queue:
Invoice Created
Invoice Updated
Invoice Paid
ğŸ›‘ If multiple consumers process these messages at the same time, the order may get messed up:
âŒ For example, the message "Paid" is processed first and then "Updated"!
âœ… In this case, the invoice status may be displayed incorrectly.

How to have multiple consumers but maintain the processing order?
âœ… There is no standard RabbitMQ solution for this problem.
âœ… But there are two general ways to handle this issue:

Method 1: One queue for each message type
ğŸ”¹ Instead of putting all messages in one queue, create a separate queue for each message type.
âœ… queue.invoice.created
âœ… queue.invoice.updated
âœ… queue.invoice.paid
ğŸš€ This method keeps important messages like Invoice Paid in a separate queue and their order is not disturbed.

Method 2: Using "Message Grouping"
ğŸ”¹ In some messaging systems like Kafka, we have a concept called Message Key that sends all messages related to a specific group to a specific consumer.
ğŸ”¹ In RabbitMQ, this is not possible by default, but you can always send related messages to a specific consumer using Consistent Hash Exchange.

How to handle multiple message types in RabbitMQ?
In RabbitMQ, there are two general methods for handling messages of different types:

Method 1: One Queue per Message Type
ğŸ”¹ In this method, we have a separate queue for each message type.
ğŸ”¹ Each queue receives only one type of message with a specific routing key.
âœ… Example:
Suppose we have two message types:
Invoice Paid
Invoice Created
In this method, we will have two separate queues:
ğŸ“Œ queue.invoice.paid (receives only paid messages)
ğŸ“Œ queue.invoice.created (receives only created messages)
ğŸš€ Advantages:
âœ… Simpler code for the consumer (since each queue has only one message type).
âœ… It is possible to manage the processing of each message type separately.
âŒ Disadvantages:
ğŸ”¸ The number of queues increases, and we have to manage all of them.

Method 2: One Queue for Multiple Message Types
ğŸ”¹ In this method, we have one queue that receives multiple message types.
ğŸ”¹ Messages are identified using a header or a variable in the payload to indicate what type they are.
âœ… Example:
We put the same previous messages (Invoice Paid and Invoice Created) in a common queue:
ğŸ“Œ queue.invoice (receives both paid and created messages)
ğŸ”¹ In this method, we identify the message type through the message header.
ğŸ”¹ In Spring, this value is automatically placed in the Type ID.
ğŸš€ Advantages:
âœ… The number of queues is less, so RabbitMQ management becomes easier.
âŒ Disadvantages:
ğŸ”¸ Consumers need to check what type the message is, which makes coding a bit more complicated.
ğŸ”¸ In languages other than Java/Spring, message type conversion may be harder.
